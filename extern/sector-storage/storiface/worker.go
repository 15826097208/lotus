package storiface

import (
	"context"
	"errors"
	"fmt"
	"io"
	"time"

	"github.com/google/uuid"
	"github.com/ipfs/go-cid"

	"github.com/filecoin-project/go-state-types/abi"
	"github.com/filecoin-project/specs-storage/storage"

	"github.com/filecoin-project/lotus/extern/sector-storage/sealtasks"
)

// WorkerInfo contains information about the worker such as it's hostname and the
// available hardware resources. This information is used by the Miner's scheduler
// to choose workers for scheduling sealing/unsealing tasks.
type WorkerInfo struct {
	Hostname string

	Resources WorkerResources
}

// WorkerResources contains information about the hardware and computation resources available on the worker.
type WorkerResources struct {
	//MemPhysical is Total physical memory on the worker.
	MemPhysical uint64

	// MemSwap os the Total virtual memory on the worker.
	MemSwap uint64

	// MemReserved is the total memory Used by system / other processes on the worker.
	MemReserved uint64

	// CPUs is the number of logical CPUs usable by the current process
	CPUs uint64 // Logical cores

	// GPUs contains the names of the GPU devices detected on the worker.
	GPUs []string
}

type WorkerStats struct {
	Info    WorkerInfo
	Enabled bool

	MemUsedMin uint64
	MemUsedMax uint64
	GpuUsed    bool   // nolint
	CpuUse     uint64 // nolint
}

const (
	RWRetWait  = -1
	RWReturned = -2
	RWRetDone  = -3
)

type WorkerJob struct {
	ID     CallID
	Sector abi.SectorID
	Task   sealtasks.TaskType

	// 1+ - assigned
	// 0  - running
	// -1 - ret-wait
	// -2 - returned
	// -3 - ret-done
	RunWait int
	Start   time.Time

	Hostname string `json:",omitempty"` // optional, set for ret-wait jobs
}

// CallID uniquely identifies a task submitted by a miner to a worker.
// It is generated by the worker when it receives a RPC request to perform a task and is returned
// to the miner as a response to the RPC call so it can use it to track the status of the task.
type CallID struct {
	// Sector identifies the sector for which the worker is performing the task.
	Sector abi.SectorID
	// ID is a uuid generated by the worker when it receives a RPC request from the miner.
	ID uuid.UUID
}

func (c CallID) String() string {
	return fmt.Sprintf("%d-%d-%s", c.Sector.Miner, c.Sector.Number, c.ID)
}

var _ fmt.Stringer = &CallID{}

var UndefCall CallID

// WorkerCalls is the Worker's RPC interface that the miner calls to schedule sealing/unsealing tasks on the worker.
// Tasks are executed asynchronously by the worker and the response is later returned to the Miner by using the Miner's `WorkerReturn` RPC interface.
// Miner can use the `CallID` returned by the worker to track the status of the task.
type WorkerCalls interface {
	// AddPiece schedules a task to add a Piece to an Unsealed sector.
	// If this is the first Piece being added to the given Sector, the worker will create an Unsealed Sector file on
	// one of the sealing scratch spaces in the local sector store to add the given Piece.
	// If the given Sector already contains existing Pieces, the worker will add the given Piece to the corresponding Unsealed Sector file.
	// If the worker does NOT have the Unsealed sector file, it will fetch it from a worker that has it before adding the Piece.
	// The call will fail of the Worker is NOT able to allocate space to store the Unsealed sector file.
	AddPiece(ctx context.Context, sector storage.SectorRef, pieceSizes []abi.UnpaddedPieceSize, newPieceSize abi.UnpaddedPieceSize, pieceData storage.Data) (CallID, error)

	// SealPreCommit1 schedules a task to perform the `SealPreCommit1` stage of a Sector being sealed.
	// If the worker does NOT have the Unsealed file for the given Sector, it will fetch it from a Worker that has it in order
	// to execute the `SealPreCommit1`.
	// The resulting Sealing files will be stored on the Worker on one of the Sealing scratch spaces of the sector store.
	// The call will fail if the Worker is NOT able to allocate space to store the Unsealing & Sealing files.
	SealPreCommit1(ctx context.Context, sector storage.SectorRef, ticket abi.SealRandomness, pieces []abi.PieceInfo) (CallID, error)

	// SealPreCommit2 schedules a task to perform the `SealPreCommit2` stage of a sector being sealed.
	// If the worker does NOT have the Sealing files for the Sector, it will fetch it from a worker that has them
	// and store them on one of the Sealing scratch spaces of the sector store before executing the `SealPreCommit2`.
	// The call will fail if the Worker is NOT able to allocate space to store the Sealing files.
	SealPreCommit2(ctx context.Context, sector storage.SectorRef, pc1o storage.PreCommit1Out) (CallID, error)

	// SealCommit1 schedules a task to perform the `SealCommit1` stage of a sector being sealed.
	// If the worker does NOT have the Sealing files for the Sector, it will fetch it from a worker that has them
	// and store them on one of the Sealing scratch spaces of the sector store before executing the `SealCommit1`.
	// The call will fail if the Worker is NOT able to allocate space to store the Sealing files.
	SealCommit1(ctx context.Context, sector storage.SectorRef, ticket abi.SealRandomness, seed abi.InteractiveSealRandomness, pieces []abi.PieceInfo, cids storage.SectorCids) (CallID, error)

	// SealCommit2 schedules a task to perform the `SealCommit2` stage of a sector being sealed.
	SealCommit2(ctx context.Context, sector storage.SectorRef, c1o storage.Commit1Out) (CallID, error)

	// FinalizeSector schedules a task to perform the `FinalizeSector` stage of a sector being sealed.
	// As a part of this task, the worker fetches(if required) and stores the cached sealing file on one of the long term
	// storage directories in the local sector store.
	// It fetches/keeps around the  Unsealed file in the  Sealing scratch space if `keepUnsealed` is non-zero.
	// The Unsealed file will be moved to long term storage later when the Miner calls `MoveStorage`.
	// If `keepUnsealed` is set to zero, it will remove the Unsealed file locally and from all other workers that have it.
	FinalizeSector(ctx context.Context, sector storage.SectorRef, keepUnsealed []storage.Range) (CallID, error)

	// TODO: ReleaseUnsealed has still not been implemented.
	ReleaseUnsealed(ctx context.Context, sector storage.SectorRef, safeToFree []storage.Range) (CallID, error)

	// MoveStorage schedules a task to move a Sealed & Finalized sector to the long term storage space in the sector store.
	MoveStorage(ctx context.Context, sector storage.SectorRef, types SectorFileType) (CallID, error)

	// UnsealPiece schedules a task to Unseal a given Piece from a sealed/unsealed sector.
	// After the Unseal is complete, all sealed copies of the sector will be removed from the local Sector store.
	UnsealPiece(context.Context, storage.SectorRef, UnpaddedByteIndex, abi.UnpaddedPieceSize, abi.SealRandomness, cid.Cid) (CallID, error)

	// ReadPiece schedules a task to read Piece data for a given Piece from an Unsealed sector containing the Unsealed Piece.
	ReadPiece(context.Context, io.Writer, storage.SectorRef, UnpaddedByteIndex, abi.UnpaddedPieceSize) (CallID, error)

	// Fetch schedules a task to fetch a Sector file for the given sector and file type and place it in a local
	// storage directory with the given path type. If the Worker already has the given file at the requisite path type, this essentially becomes a no-op.
	// Otherwise, it can fetch it from another worker which has the required file.
	Fetch(context.Context, storage.SectorRef, SectorFileType, PathType, AcquireMode) (CallID, error)
}

// ErrorCode is the error code returned by the worker(if there is an error) to the miner as a part of the RPC response.
type ErrorCode int

const (
	ErrUnknown ErrorCode = iota
)

const (
	// ErrTempUnknown represents Temp Errors.
	ErrTempUnknown ErrorCode = iota + 100
	// ErrTempWorkerRestart represents an error that occurred due to a worker restarting.
	ErrTempWorkerRestart
	// ErrTempAllocateSpace means that the worker dosen't have enough space in it's sector store for a new allocation.
	ErrTempAllocateSpace
)

// CallError is used by the worker to wrap information about an error encountered while executing a task
// and is sent to the miner as part of the RPC response.
type CallError struct {
	Code    ErrorCode
	Message string
	sub     error
}

func (c *CallError) Error() string {
	return fmt.Sprintf("storage call error %d: %s", c.Code, c.Message)
}

func (c *CallError) Unwrap() error {
	if c.sub != nil {
		return c.sub
	}

	return errors.New(c.Message)
}

func Err(code ErrorCode, sub error) *CallError {
	return &CallError{
		Code:    code,
		Message: sub.Error(),

		sub: sub,
	}
}

// WorkerReturn is the Miner's RPC interface called by the Worker to send the response
// for a task scheduled by the miner.
type WorkerReturn interface {
	// ReturnAddPiece is called by the Worker to return the response for an `AddPiece` task previously scheduled by the Miner.
	ReturnAddPiece(ctx context.Context, callID CallID, pi abi.PieceInfo, err *CallError) error
	// ReturnSealPreCommit1 is called by the Worker to return the response for an `SealPreCommit1` task previously scheduled by the Miner.
	ReturnSealPreCommit1(ctx context.Context, callID CallID, p1o storage.PreCommit1Out, err *CallError) error
	// ReturnSealPreCommit2 is called by the Worker to return the response for an `SealPreCommit2` task previously scheduled by the Miner.
	ReturnSealPreCommit2(ctx context.Context, callID CallID, sealed storage.SectorCids, err *CallError) error
	// ReturnSealCommit1 is called by the Worker to return the response for an `SealCommit1` task previously scheduled by the Miner.
	ReturnSealCommit1(ctx context.Context, callID CallID, out storage.Commit1Out, err *CallError) error
	// ReturnSealCommit2 is called by the Worker to return the response for an `SealCommit2` task previously scheduled by the Miner.
	ReturnSealCommit2(ctx context.Context, callID CallID, proof storage.Proof, err *CallError) error
	// ReturnFinalizeSector is called by the Worker to return the response for an `FinalizeSector` task previously scheduled by the Miner.
	ReturnFinalizeSector(ctx context.Context, callID CallID, err *CallError) error
	// ReturnReleaseUnsealed is called by the Worker to return the response for an `ReleaseUnsealed` task previously scheduled by the Miner.
	ReturnReleaseUnsealed(ctx context.Context, callID CallID, err *CallError) error
	// ReturnMoveStorage is called by the Worker to return the response for an `MoveStorage` task previously scheduled by the Miner.
	ReturnMoveStorage(ctx context.Context, callID CallID, err *CallError) error
	// ReturnUnsealPiece is called by the Worker to return the response for an `UnsealPiece` task previously scheduled by the Miner.
	ReturnUnsealPiece(ctx context.Context, callID CallID, err *CallError) error
	// ReturnReadPiece is called by the Worker to return the response for an `ReadPiece` task previously scheduled by the Miner.
	ReturnReadPiece(ctx context.Context, callID CallID, ok bool, err *CallError) error
	// ReturnFetch is called by the Worker to return the response for an `Fetch` task previously scheduled by the Miner.
	ReturnFetch(ctx context.Context, callID CallID, err *CallError) error
}
